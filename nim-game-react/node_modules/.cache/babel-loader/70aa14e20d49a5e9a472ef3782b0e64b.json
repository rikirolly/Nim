{"ast":null,"code":"var _jsxFileName = \"/home/riki/Desktop/Nim/nim-game-react/src/components/Game.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport NimRow from './NimRow';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst INITIAL_PILES = [3, 4, 5]; // Configurazione iniziale delle pile\nconst PLAYER_HUMAN = 'human';\nconst PLAYER_AI = 'ai';\nconst AI_DELAY = 1500; // Ritardo per la mossa dell'AI in ms\n\nfunction Game() {\n  _s();\n  const [piles, setPiles] = useState(INITIAL_PILES);\n  const [currentPlayer, setCurrentPlayer] = useState(PLAYER_HUMAN);\n  const [selectedRow, setSelectedRow] = useState(null);\n  const [selectedCount, setSelectedCount] = useState(0);\n  const [aiRemoving, setAiRemoving] = useState({}); // { rowIndex: [pieceIndex1, pieceIndex2...] }\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n\n  // Funzione per gestire il click su un pezzo\n  const handlePieceClick = (rowIndex, pieceIndex) => {\n    if (currentPlayer !== PLAYER_HUMAN || gameOver) return;\n    const currentPileCount = piles[rowIndex];\n    // Se si clicca su una riga diversa o si deseleziona cliccando sul primo pezzo non selezionato\n    if (selectedRow !== null && selectedRow !== rowIndex) {\n      // Non permettere selezione da righe multiple\n      console.log(\"Seleziona pezzi solo da una riga alla volta.\");\n      return;\n    }\n\n    // Calcola quanti pezzi sono stati selezionati cliccando su questo indice\n    const count = currentPileCount - pieceIndex;\n    if (selectedRow === rowIndex && count === selectedCount) {\n      // Deseleziona tutto se si clicca sullo stesso pezzo che definisce la selezione corrente\n      setSelectedRow(null);\n      setSelectedCount(0);\n    } else {\n      // Seleziona i pezzi\n      setSelectedRow(rowIndex);\n      setSelectedCount(count);\n    }\n  };\n\n  // Funzione per confermare la mossa dell'utente\n  const handleTakeTurn = () => {\n    if (selectedRow === null || selectedCount === 0 || gameOver) return;\n    const newPiles = [...piles];\n    newPiles[selectedRow] -= selectedCount;\n    setPiles(newPiles);\n    setSelectedRow(null);\n    setSelectedCount(0);\n\n    // Misère Play: Chi svuota le pile perde\n    if (checkGameOver(newPiles)) {\n      setGameOver(true);\n      setWinner(PLAYER_AI); // L'AI vince perché l'umano ha preso l'ultimo pezzo\n    } else {\n      setCurrentPlayer(PLAYER_AI);\n    }\n  };\n\n  // Funzione per la mossa dell'AI (logica semplice per ora)\n  const performAiMove = () => {\n    setAiRemoving({}); // Resetta l'evidenziazione precedente\n\n    // Logica AI molto semplice: rimuove 1 pezzo dalla prima pila non vuota\n    let moveMade = false;\n    let aiRowIndex = -1;\n    let aiRemoveCount = 0;\n    const newPiles = [...piles];\n    for (let i = 0; i < newPiles.length; i++) {\n      if (newPiles[i] > 0) {\n        aiRowIndex = i;\n        aiRemoveCount = 1; // Rimuove sempre 1 pezzo\n        newPiles[i] -= aiRemoveCount;\n        moveMade = true;\n        break;\n      }\n    }\n    if (moveMade) {\n      // Evidenzia i pezzi che l'AI sta rimuovendo\n      const removingIndices = [];\n      const startPieceIndex = piles[aiRowIndex] - aiRemoveCount;\n      for (let i = 0; i < aiRemoveCount; i++) {\n        removingIndices.push(startPieceIndex + i);\n      }\n      setAiRemoving({\n        [aiRowIndex]: removingIndices\n      });\n\n      // Applica la mossa dopo un ritardo\n      setTimeout(() => {\n        setPiles(newPiles);\n        setAiRemoving({}); // Rimuovi evidenziazione\n\n        // Misère Play: Chi svuota le pile perde\n        if (checkGameOver(newPiles)) {\n          setGameOver(true);\n          setWinner(PLAYER_HUMAN); // L'umano vince perché l'AI ha preso l'ultimo pezzo\n        } else {\n          setCurrentPlayer(PLAYER_HUMAN);\n        }\n      }, AI_DELAY);\n    }\n  };\n\n  // Controlla se il gioco è finito\n  const checkGameOver = currentPiles => {\n    return currentPiles.every(count => count === 0);\n  };\n\n  // Effetto per triggerare la mossa dell'AI quando è il suo turno\n  useEffect(() => {\n    if (currentPlayer === PLAYER_AI && !gameOver) {\n      // Aggiungi un ritardo per far vedere la mossa dell'AI\n      const timer = setTimeout(performAiMove, AI_DELAY / 2); // Inizia la logica un po' prima\n      return () => clearTimeout(timer);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentPlayer, gameOver, piles]); // Aggiunto piles per rieseguire se le pile cambiano esternamente\n\n  // Determina lo stato del gioco da visualizzare\n  let status;\n  if (gameOver) {\n    // Il messaggio di vittoria ora riflette la regola Misère\n    status = winner === PLAYER_HUMAN ? 'Hai vinto! (L\\'AI ha preso l\\'ultimo pezzo)' : 'L\\'AI ha vinto! (Hai preso l\\'ultimo pezzo)';\n  } else {\n    status = currentPlayer === PLAYER_HUMAN ? 'Il tuo turno' : 'Turno dell\\'AI...';\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-status\",\n      children: status\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"nim-rows\",\n      children: piles.map((count, index) => /*#__PURE__*/_jsxDEV(NimRow, {\n        rowIndex: index,\n        piecesCount: count,\n        selectedCount: selectedRow === index ? selectedCount : 0,\n        aiRemovingIndices: aiRemoving[index] || [],\n        onPieceClick: handlePieceClick\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 138,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 136,\n      columnNumber: 7\n    }, this), currentPlayer === PLAYER_HUMAN && !gameOver && /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleTakeTurn,\n      disabled: selectedCount === 0,\n      children: \"Conferma Mossa\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 149,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 134,\n    columnNumber: 5\n  }, this);\n}\n_s(Game, \"tsxB+03avKhm5bRdhmAL65IS/+8=\");\n_c = Game;\nexport default Game;\nvar _c;\n$RefreshReg$(_c, \"Game\");","map":{"version":3,"names":["React","useState","useEffect","NimRow","jsxDEV","_jsxDEV","INITIAL_PILES","PLAYER_HUMAN","PLAYER_AI","AI_DELAY","Game","_s","piles","setPiles","currentPlayer","setCurrentPlayer","selectedRow","setSelectedRow","selectedCount","setSelectedCount","aiRemoving","setAiRemoving","gameOver","setGameOver","winner","setWinner","handlePieceClick","rowIndex","pieceIndex","currentPileCount","console","log","count","handleTakeTurn","newPiles","checkGameOver","performAiMove","moveMade","aiRowIndex","aiRemoveCount","i","length","removingIndices","startPieceIndex","push","setTimeout","currentPiles","every","timer","clearTimeout","status","className","children","fileName","_jsxFileName","lineNumber","columnNumber","map","index","piecesCount","aiRemovingIndices","onPieceClick","onClick","disabled","_c","$RefreshReg$"],"sources":["/home/riki/Desktop/Nim/nim-game-react/src/components/Game.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport NimRow from './NimRow';\n\nconst INITIAL_PILES = [3, 4, 5]; // Configurazione iniziale delle pile\nconst PLAYER_HUMAN = 'human';\nconst PLAYER_AI = 'ai';\nconst AI_DELAY = 1500; // Ritardo per la mossa dell'AI in ms\n\nfunction Game() {\n  const [piles, setPiles] = useState(INITIAL_PILES);\n  const [currentPlayer, setCurrentPlayer] = useState(PLAYER_HUMAN);\n  const [selectedRow, setSelectedRow] = useState(null);\n  const [selectedCount, setSelectedCount] = useState(0);\n  const [aiRemoving, setAiRemoving] = useState({}); // { rowIndex: [pieceIndex1, pieceIndex2...] }\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n\n  // Funzione per gestire il click su un pezzo\n  const handlePieceClick = (rowIndex, pieceIndex) => {\n    if (currentPlayer !== PLAYER_HUMAN || gameOver) return;\n\n    const currentPileCount = piles[rowIndex];\n    // Se si clicca su una riga diversa o si deseleziona cliccando sul primo pezzo non selezionato\n    if (selectedRow !== null && selectedRow !== rowIndex) {\n        // Non permettere selezione da righe multiple\n        console.log(\"Seleziona pezzi solo da una riga alla volta.\");\n        return;\n    }\n\n    // Calcola quanti pezzi sono stati selezionati cliccando su questo indice\n    const count = currentPileCount - pieceIndex;\n\n    if (selectedRow === rowIndex && count === selectedCount) {\n        // Deseleziona tutto se si clicca sullo stesso pezzo che definisce la selezione corrente\n        setSelectedRow(null);\n        setSelectedCount(0);\n    } else {\n        // Seleziona i pezzi\n        setSelectedRow(rowIndex);\n        setSelectedCount(count);\n    }\n  };\n\n  // Funzione per confermare la mossa dell'utente\n  const handleTakeTurn = () => {\n    if (selectedRow === null || selectedCount === 0 || gameOver) return;\n\n    const newPiles = [...piles];\n    newPiles[selectedRow] -= selectedCount;\n    setPiles(newPiles);\n    setSelectedRow(null);\n    setSelectedCount(0);\n\n    // Misère Play: Chi svuota le pile perde\n    if (checkGameOver(newPiles)) {\n        setGameOver(true);\n        setWinner(PLAYER_AI); // L'AI vince perché l'umano ha preso l'ultimo pezzo\n    } else {\n        setCurrentPlayer(PLAYER_AI);\n    }\n  };\n\n  // Funzione per la mossa dell'AI (logica semplice per ora)\n  const performAiMove = () => {\n    setAiRemoving({}); // Resetta l'evidenziazione precedente\n\n    // Logica AI molto semplice: rimuove 1 pezzo dalla prima pila non vuota\n    let moveMade = false;\n    let aiRowIndex = -1;\n    let aiRemoveCount = 0;\n    const newPiles = [...piles];\n\n    for (let i = 0; i < newPiles.length; i++) {\n      if (newPiles[i] > 0) {\n        aiRowIndex = i;\n        aiRemoveCount = 1; // Rimuove sempre 1 pezzo\n        newPiles[i] -= aiRemoveCount;\n        moveMade = true;\n        break;\n      }\n    }\n\n    if (moveMade) {\n      // Evidenzia i pezzi che l'AI sta rimuovendo\n      const removingIndices = [];\n      const startPieceIndex = piles[aiRowIndex] - aiRemoveCount;\n      for(let i = 0; i < aiRemoveCount; i++) {\n          removingIndices.push(startPieceIndex + i);\n      }\n      setAiRemoving({ [aiRowIndex]: removingIndices });\n\n\n      // Applica la mossa dopo un ritardo\n      setTimeout(() => {\n        setPiles(newPiles);\n        setAiRemoving({}); // Rimuovi evidenziazione\n\n        // Misère Play: Chi svuota le pile perde\n        if (checkGameOver(newPiles)) {\n          setGameOver(true);\n          setWinner(PLAYER_HUMAN); // L'umano vince perché l'AI ha preso l'ultimo pezzo\n        } else {\n          setCurrentPlayer(PLAYER_HUMAN);\n        }\n      }, AI_DELAY);\n    }\n  };\n\n  // Controlla se il gioco è finito\n  const checkGameOver = (currentPiles) => {\n    return currentPiles.every(count => count === 0);\n  };\n\n  // Effetto per triggerare la mossa dell'AI quando è il suo turno\n  useEffect(() => {\n    if (currentPlayer === PLAYER_AI && !gameOver) {\n      // Aggiungi un ritardo per far vedere la mossa dell'AI\n      const timer = setTimeout(performAiMove, AI_DELAY / 2); // Inizia la logica un po' prima\n      return () => clearTimeout(timer);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentPlayer, gameOver, piles]); // Aggiunto piles per rieseguire se le pile cambiano esternamente\n\n  // Determina lo stato del gioco da visualizzare\n  let status;\n  if (gameOver) {\n    // Il messaggio di vittoria ora riflette la regola Misère\n    status = winner === PLAYER_HUMAN ? 'Hai vinto! (L\\'AI ha preso l\\'ultimo pezzo)' : 'L\\'AI ha vinto! (Hai preso l\\'ultimo pezzo)';\n  } else {\n    status = currentPlayer === PLAYER_HUMAN ? 'Il tuo turno' : 'Turno dell\\'AI...';\n  }\n\n  return (\n    <div className=\"game-container\">\n      <div className=\"game-status\">{status}</div>\n      <div className=\"nim-rows\">\n        {piles.map((count, index) => (\n          <NimRow\n            key={index}\n            rowIndex={index}\n            piecesCount={count}\n            selectedCount={selectedRow === index ? selectedCount : 0}\n            aiRemovingIndices={aiRemoving[index] || []}\n            onPieceClick={handlePieceClick}\n          />\n        ))}\n      </div>\n      {currentPlayer === PLAYER_HUMAN && !gameOver && (\n        <button onClick={handleTakeTurn} disabled={selectedCount === 0}>\n          Conferma Mossa\n        </button>\n      )}\n    </div>\n  );\n}\n\nexport default Game;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}