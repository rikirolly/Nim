{"ast":null,"code":"var _jsxFileName = \"/home/riki/Desktop/Nim/nim-game-react/src/components/Game.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport NimRow from './NimRow';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst INITIAL_PILES = [9, 7, 5, 3]; // Configurazione iniziale delle pile aggiornata\nconst PLAYER_HUMAN = 'human';\nconst PLAYER_AI = 'ai';\nconst AI_DELAY = 1500; // Ritardo per la mossa dell'AI in ms\n\n// Funzione helper per calcolare il Nim-sum\nconst calculateNimSum = piles => piles.reduce((xorSum, count) => xorSum ^ count, 0);\n\n// Funzione helper per calcolare le mosse vincenti suggerite (per Debug - Standard Nim)\nconst calculateWinningMoves = piles => {\n  const winningMoves = [];\n  const currentNimSum = calculateNimSum(piles);\n  if (currentNimSum === 0) {\n    // Se il Nim-sum è già 0, qualsiasi mossa porta a un Nim-sum non zero (N-position).\n    return [];\n  }\n\n  // Trova tutte le mosse che portano a Nim-sum 0 (P-position)\n  for (let i = 0; i < piles.length; i++) {\n    if (piles[i] === 0) continue;\n    const targetSize = piles[i] ^ currentNimSum;\n    if (targetSize < piles[i]) {\n      const removeCount = piles[i] - targetSize;\n      winningMoves.push({\n        rowIndex: i,\n        removeCount: removeCount\n      });\n    }\n  }\n  return winningMoves;\n};\nfunction Game() {\n  _s();\n  const [piles, setPiles] = useState(INITIAL_PILES);\n  const [currentPlayer, setCurrentPlayer] = useState(PLAYER_HUMAN);\n  const [selectedRow, setSelectedRow] = useState(null);\n  const [selectedCount, setSelectedCount] = useState(0);\n  const [aiRemoving, setAiRemoving] = useState({}); // { rowIndex: [pieceIndex1, pieceIndex2...] }\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n  const [isDebugMode, setIsDebugMode] = useState(false); // Stato per la modalità debug\n\n  // Funzione per gestire il click su un pezzo\n  const handlePieceClick = (rowIndex, pieceIndex) => {\n    if (currentPlayer !== PLAYER_HUMAN || gameOver) return;\n    const currentPileCount = piles[rowIndex];\n    // Se si clicca su una riga diversa o si deseleziona cliccando sul primo pezzo non selezionato\n    if (selectedRow !== null && selectedRow !== rowIndex) {\n      // Non permettere selezione da righe multiple\n      console.log(\"Seleziona pezzi solo da una riga alla volta.\");\n      return;\n    }\n\n    // Calcola quanti pezzi sono stati selezionati cliccando su questo indice\n    const count = currentPileCount - pieceIndex;\n    if (selectedRow === rowIndex && count === selectedCount) {\n      // Deseleziona tutto se si clicca sullo stesso pezzo che definisce la selezione corrente\n      setSelectedRow(null);\n      setSelectedCount(0);\n    } else {\n      // Seleziona i pezzi\n      setSelectedRow(rowIndex);\n      setSelectedCount(count);\n    }\n  };\n\n  // Funzione per confermare la mossa dell'utente (Standard Nim)\n  const handleTakeTurn = () => {\n    if (selectedRow === null || selectedCount === 0 || gameOver) return;\n    const newPiles = [...piles];\n    newPiles[selectedRow] -= selectedCount;\n    setPiles(newPiles);\n    setSelectedRow(null);\n    setSelectedCount(0);\n\n    // Standard Play: Chi prende l'ultimo pezzo vince\n    if (checkGameOver(newPiles)) {\n      setGameOver(true);\n      setWinner(PLAYER_HUMAN); // L'umano vince perché ha preso l'ultimo pezzo\n    } else {\n      setCurrentPlayer(PLAYER_AI);\n    }\n  };\n\n  // Funzione per la mossa dell'AI con strategia Nim-sum (Standard Nim)\n  const performAiMove = () => {\n    setAiRemoving({}); // Resetta evidenziazione\n\n    const currentNimSum = calculateNimSum(piles);\n    let bestMove = null; // { rowIndex: number, removeCount: number }\n\n    if (currentNimSum !== 0) {\n      // Posizione vincente (N-position): trova una mossa per portare Nim-sum a 0 (P-position)\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] === 0) continue;\n        const targetSize = piles[i] ^ currentNimSum;\n        if (targetSize < piles[i]) {\n          const removeCount = piles[i] - targetSize;\n          bestMove = {\n            rowIndex: i,\n            removeCount: removeCount\n          };\n          break; // Trovata la mossa ottimale\n        }\n      }\n    }\n    if (bestMove === null) {\n      // Posizione perdente (P-position, Nim-sum è 0) o fallback:\n      // Fai una mossa qualsiasi, di solito rimuovere 1 pezzo dalla pila più grande.\n      let largestPileIndex = -1;\n      let maxPieces = 0;\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] > maxPieces) {\n          maxPieces = piles[i];\n          largestPileIndex = i;\n        }\n      }\n      if (largestPileIndex !== -1) {\n        bestMove = {\n          rowIndex: largestPileIndex,\n          removeCount: 1\n        };\n      } else {\n        console.error(\"AI non può muovere!\");\n        return;\n      }\n    }\n\n    // Esegui la mossa scelta\n    const {\n      rowIndex: aiRowIndex,\n      removeCount: aiRemoveCount\n    } = bestMove;\n    const newPiles = [...piles];\n    newPiles[aiRowIndex] -= aiRemoveCount;\n\n    // Evidenzia i pezzi\n    const removingIndices = [];\n    const startPieceIndex = piles[aiRowIndex] - aiRemoveCount;\n    for (let i = 0; i < aiRemoveCount; i++) {\n      removingIndices.push(startPieceIndex + i);\n    }\n    setAiRemoving({\n      [aiRowIndex]: removingIndices\n    });\n\n    // Applica la mossa dopo un ritardo\n    setTimeout(() => {\n      setPiles(newPiles);\n      setAiRemoving({}); // Rimuovi evidenziazione\n\n      // Standard Play: Chi prende l'ultimo pezzo vince\n      if (checkGameOver(newPiles)) {\n        setGameOver(true);\n        setWinner(PLAYER_AI); // L'AI vince perché ha preso l'ultimo pezzo\n      } else {\n        setCurrentPlayer(PLAYER_HUMAN);\n      }\n    }, AI_DELAY);\n  };\n\n  // Controlla se il gioco è finito\n  const checkGameOver = currentPiles => {\n    return currentPiles.every(count => count === 0);\n  };\n\n  // Effetto per triggerare la mossa dell'AI quando è il suo turno\n  useEffect(() => {\n    if (currentPlayer === PLAYER_AI && !gameOver) {\n      // Aggiungi un ritardo per far vedere la mossa dell'AI\n      const timer = setTimeout(performAiMove, AI_DELAY / 2); // Inizia la logica un po' prima\n      return () => clearTimeout(timer);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentPlayer, gameOver, piles]); // Aggiunto piles per rieseguire se le pile cambiano esternamente\n\n  // Funzione per attivare/disattivare la modalità debug\n  const toggleDebugMode = () => {\n    setIsDebugMode(prevMode => !prevMode);\n  };\n\n  // Determina lo stato del gioco da visualizzare (Standard Nim)\n  let status;\n  if (gameOver) {\n    status = winner === PLAYER_HUMAN ? 'Hai vinto!' : 'L\\'AI ha vinto!';\n  } else {\n    status = currentPlayer === PLAYER_HUMAN ? 'Il tuo turno' : 'Turno dell\\'AI...';\n  }\n\n  // Calcola Nim-sum e mosse suggerite per il debug\n  const currentNimSum = calculateNimSum(piles);\n  const suggestedMoves = isDebugMode ? calculateWinningMoves(piles) : [];\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-status\",\n      children: status\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 191,\n      columnNumber: 7\n    }, this), isDebugMode && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"debug-info\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Nim-Sum (XOR): \", currentNimSum, \" (\", currentNimSum.toString(2), \")\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 196,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Mosse suggerite (per Nim-Sum = 0):\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 197,\n        columnNumber: 11\n      }, this), suggestedMoves.length > 0 ? /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: suggestedMoves.map((move, index) => /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [\"Rimuovi \", move.removeCount, \" da Pila \", move.rowIndex + 1, \" (indice \", move.rowIndex, \")\"]\n        }, index, true, {\n          fileName: _jsxFileName,\n          lineNumber: 201,\n          columnNumber: 17\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 199,\n        columnNumber: 13\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        children: currentNimSum === 0 ? \"Nessuna mossa porta a Nim-Sum 0 (sei in P-position).\" : \"Errore nel calcolo mosse?\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 207,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"nim-rows\",\n      children: piles.map((count, index) => /*#__PURE__*/_jsxDEV(NimRow, {\n        rowIndex: index,\n        piecesCount: count,\n        selectedCount: selectedRow === index ? selectedCount : 0,\n        aiRemovingIndices: aiRemoving[index] || [],\n        onPieceClick: handlePieceClick\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 214,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 212,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"action-buttons\",\n      children: [currentPlayer === PLAYER_HUMAN && !gameOver && /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleTakeTurn,\n        disabled: selectedCount === 0,\n        children: \"Conferma Mossa\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 228,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: toggleDebugMode,\n        className: \"debug-button\",\n        children: isDebugMode ? 'Nascondi Debug' : 'Mostra Debug'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 233,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 226,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 190,\n    columnNumber: 5\n  }, this);\n}\n_s(Game, \"zVNGRUZXoOo+JhVYLb3d40C78EE=\");\n_c = Game;\nexport default Game;\nvar _c;\n$RefreshReg$(_c, \"Game\");","map":{"version":3,"names":["React","useState","useEffect","NimRow","jsxDEV","_jsxDEV","INITIAL_PILES","PLAYER_HUMAN","PLAYER_AI","AI_DELAY","calculateNimSum","piles","reduce","xorSum","count","calculateWinningMoves","winningMoves","currentNimSum","i","length","targetSize","removeCount","push","rowIndex","Game","_s","setPiles","currentPlayer","setCurrentPlayer","selectedRow","setSelectedRow","selectedCount","setSelectedCount","aiRemoving","setAiRemoving","gameOver","setGameOver","winner","setWinner","isDebugMode","setIsDebugMode","handlePieceClick","pieceIndex","currentPileCount","console","log","handleTakeTurn","newPiles","checkGameOver","performAiMove","bestMove","largestPileIndex","maxPieces","error","aiRowIndex","aiRemoveCount","removingIndices","startPieceIndex","setTimeout","currentPiles","every","timer","clearTimeout","toggleDebugMode","prevMode","status","suggestedMoves","className","children","fileName","_jsxFileName","lineNumber","columnNumber","toString","map","move","index","piecesCount","aiRemovingIndices","onPieceClick","onClick","disabled","_c","$RefreshReg$"],"sources":["/home/riki/Desktop/Nim/nim-game-react/src/components/Game.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport NimRow from './NimRow';\n\nconst INITIAL_PILES = [9, 7, 5, 3]; // Configurazione iniziale delle pile aggiornata\nconst PLAYER_HUMAN = 'human';\nconst PLAYER_AI = 'ai';\nconst AI_DELAY = 1500; // Ritardo per la mossa dell'AI in ms\n\n// Funzione helper per calcolare il Nim-sum\nconst calculateNimSum = (piles) => piles.reduce((xorSum, count) => xorSum ^ count, 0);\n\n// Funzione helper per calcolare le mosse vincenti suggerite (per Debug - Standard Nim)\nconst calculateWinningMoves = (piles) => {\n  const winningMoves = [];\n  const currentNimSum = calculateNimSum(piles);\n\n  if (currentNimSum === 0) {\n    // Se il Nim-sum è già 0, qualsiasi mossa porta a un Nim-sum non zero (N-position).\n    return [];\n  }\n\n  // Trova tutte le mosse che portano a Nim-sum 0 (P-position)\n  for (let i = 0; i < piles.length; i++) {\n    if (piles[i] === 0) continue;\n    const targetSize = piles[i] ^ currentNimSum;\n    if (targetSize < piles[i]) {\n      const removeCount = piles[i] - targetSize;\n      winningMoves.push({ rowIndex: i, removeCount: removeCount });\n    }\n  }\n  return winningMoves;\n};\n\n\nfunction Game() {\n  const [piles, setPiles] = useState(INITIAL_PILES);\n  const [currentPlayer, setCurrentPlayer] = useState(PLAYER_HUMAN);\n  const [selectedRow, setSelectedRow] = useState(null);\n  const [selectedCount, setSelectedCount] = useState(0);\n  const [aiRemoving, setAiRemoving] = useState({}); // { rowIndex: [pieceIndex1, pieceIndex2...] }\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n  const [isDebugMode, setIsDebugMode] = useState(false); // Stato per la modalità debug\n\n  // Funzione per gestire il click su un pezzo\n  const handlePieceClick = (rowIndex, pieceIndex) => {\n    if (currentPlayer !== PLAYER_HUMAN || gameOver) return;\n\n    const currentPileCount = piles[rowIndex];\n    // Se si clicca su una riga diversa o si deseleziona cliccando sul primo pezzo non selezionato\n    if (selectedRow !== null && selectedRow !== rowIndex) {\n        // Non permettere selezione da righe multiple\n        console.log(\"Seleziona pezzi solo da una riga alla volta.\");\n        return;\n    }\n\n    // Calcola quanti pezzi sono stati selezionati cliccando su questo indice\n    const count = currentPileCount - pieceIndex;\n\n    if (selectedRow === rowIndex && count === selectedCount) {\n        // Deseleziona tutto se si clicca sullo stesso pezzo che definisce la selezione corrente\n        setSelectedRow(null);\n        setSelectedCount(0);\n    } else {\n        // Seleziona i pezzi\n        setSelectedRow(rowIndex);\n        setSelectedCount(count);\n    }\n  };\n\n  // Funzione per confermare la mossa dell'utente (Standard Nim)\n  const handleTakeTurn = () => {\n    if (selectedRow === null || selectedCount === 0 || gameOver) return;\n\n    const newPiles = [...piles];\n    newPiles[selectedRow] -= selectedCount;\n    setPiles(newPiles);\n    setSelectedRow(null);\n    setSelectedCount(0);\n\n    // Standard Play: Chi prende l'ultimo pezzo vince\n    if (checkGameOver(newPiles)) {\n        setGameOver(true);\n        setWinner(PLAYER_HUMAN); // L'umano vince perché ha preso l'ultimo pezzo\n    } else {\n        setCurrentPlayer(PLAYER_AI);\n    }\n  };\n\n  // Funzione per la mossa dell'AI con strategia Nim-sum (Standard Nim)\n  const performAiMove = () => {\n    setAiRemoving({}); // Resetta evidenziazione\n\n    const currentNimSum = calculateNimSum(piles);\n    let bestMove = null; // { rowIndex: number, removeCount: number }\n\n    if (currentNimSum !== 0) {\n      // Posizione vincente (N-position): trova una mossa per portare Nim-sum a 0 (P-position)\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] === 0) continue;\n        const targetSize = piles[i] ^ currentNimSum;\n        if (targetSize < piles[i]) {\n          const removeCount = piles[i] - targetSize;\n          bestMove = { rowIndex: i, removeCount: removeCount };\n          break; // Trovata la mossa ottimale\n        }\n      }\n    }\n\n    if (bestMove === null) {\n      // Posizione perdente (P-position, Nim-sum è 0) o fallback:\n      // Fai una mossa qualsiasi, di solito rimuovere 1 pezzo dalla pila più grande.\n      let largestPileIndex = -1;\n      let maxPieces = 0;\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] > maxPieces) {\n          maxPieces = piles[i];\n          largestPileIndex = i;\n        }\n      }\n      if (largestPileIndex !== -1) {\n        bestMove = { rowIndex: largestPileIndex, removeCount: 1 };\n      } else {\n         console.error(\"AI non può muovere!\");\n         return;\n      }\n    }\n\n    // Esegui la mossa scelta\n    const { rowIndex: aiRowIndex, removeCount: aiRemoveCount } = bestMove;\n    const newPiles = [...piles];\n    newPiles[aiRowIndex] -= aiRemoveCount;\n\n    // Evidenzia i pezzi\n    const removingIndices = [];\n    const startPieceIndex = piles[aiRowIndex] - aiRemoveCount;\n    for (let i = 0; i < aiRemoveCount; i++) {\n      removingIndices.push(startPieceIndex + i);\n    }\n    setAiRemoving({ [aiRowIndex]: removingIndices });\n\n    // Applica la mossa dopo un ritardo\n    setTimeout(() => {\n      setPiles(newPiles);\n      setAiRemoving({}); // Rimuovi evidenziazione\n\n      // Standard Play: Chi prende l'ultimo pezzo vince\n      if (checkGameOver(newPiles)) {\n        setGameOver(true);\n        setWinner(PLAYER_AI); // L'AI vince perché ha preso l'ultimo pezzo\n      } else {\n        setCurrentPlayer(PLAYER_HUMAN);\n      }\n    }, AI_DELAY);\n  };\n\n  // Controlla se il gioco è finito\n  const checkGameOver = (currentPiles) => {\n    return currentPiles.every(count => count === 0);\n  };\n\n  // Effetto per triggerare la mossa dell'AI quando è il suo turno\n  useEffect(() => {\n    if (currentPlayer === PLAYER_AI && !gameOver) {\n      // Aggiungi un ritardo per far vedere la mossa dell'AI\n      const timer = setTimeout(performAiMove, AI_DELAY / 2); // Inizia la logica un po' prima\n      return () => clearTimeout(timer);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentPlayer, gameOver, piles]); // Aggiunto piles per rieseguire se le pile cambiano esternamente\n\n  // Funzione per attivare/disattivare la modalità debug\n  const toggleDebugMode = () => {\n    setIsDebugMode(prevMode => !prevMode);\n  };\n\n  // Determina lo stato del gioco da visualizzare (Standard Nim)\n  let status;\n  if (gameOver) {\n    status = winner === PLAYER_HUMAN ? 'Hai vinto!' : 'L\\'AI ha vinto!';\n  } else {\n    status = currentPlayer === PLAYER_HUMAN ? 'Il tuo turno' : 'Turno dell\\'AI...';\n  }\n\n  // Calcola Nim-sum e mosse suggerite per il debug\n  const currentNimSum = calculateNimSum(piles);\n  const suggestedMoves = isDebugMode ? calculateWinningMoves(piles) : [];\n\n  return (\n    <div className=\"game-container\">\n      <div className=\"game-status\">{status}</div>\n\n      {/* Visualizzazione Debug */}\n      {isDebugMode && (\n        <div className=\"debug-info\">\n          <div>Nim-Sum (XOR): {currentNimSum} ({currentNimSum.toString(2)})</div>\n          <div>Mosse suggerite (per Nim-Sum = 0):</div>\n          {suggestedMoves.length > 0 ? (\n            <ul>\n              {suggestedMoves.map((move, index) => (\n                <li key={index}>\n                  Rimuovi {move.removeCount} da Pila {move.rowIndex + 1} (indice {move.rowIndex})\n                </li>\n              ))}\n            </ul>\n          ) : (\n            <div>{currentNimSum === 0 ? \"Nessuna mossa porta a Nim-Sum 0 (sei in P-position).\" : \"Errore nel calcolo mosse?\"}</div>\n          )}\n        </div>\n      )}\n\n      <div className=\"nim-rows\">\n        {piles.map((count, index) => (\n          <NimRow\n            key={index}\n            rowIndex={index}\n            piecesCount={count}\n            selectedCount={selectedRow === index ? selectedCount : 0}\n            aiRemovingIndices={aiRemoving[index] || []}\n            onPieceClick={handlePieceClick}\n          />\n        ))}\n      </div>\n\n      {/* Pulsanti Azione */}\n      <div className=\"action-buttons\">\n        {currentPlayer === PLAYER_HUMAN && !gameOver && (\n          <button onClick={handleTakeTurn} disabled={selectedCount === 0}>\n            Conferma Mossa\n          </button>\n        )}\n        {/* Pulsante Debug */}\n        <button onClick={toggleDebugMode} className=\"debug-button\">\n          {isDebugMode ? 'Nascondi Debug' : 'Mostra Debug'}\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default Game;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}