{"ast":null,"code":"var _jsxFileName = \"/home/riki/Desktop/Nim/nim-game-react/src/components/Game.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport NimRow from './NimRow';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst INITIAL_PILES = [7, 5, 3]; // Configurazione iniziale delle pile aggiornata\nconst PLAYER_HUMAN = 'human';\nconst PLAYER_AI = 'ai';\nconst AI_DELAY = 1500; // Ritardo per la mossa dell'AI in ms\n\n// Funzione helper per calcolare il Nim-sum\nconst calculateNimSum = piles => piles.reduce((xorSum, count) => xorSum ^ count, 0);\nfunction Game() {\n  _s();\n  const [piles, setPiles] = useState(INITIAL_PILES);\n  const [currentPlayer, setCurrentPlayer] = useState(PLAYER_HUMAN);\n  const [selectedRow, setSelectedRow] = useState(null);\n  const [selectedCount, setSelectedCount] = useState(0);\n  const [aiRemoving, setAiRemoving] = useState({}); // { rowIndex: [pieceIndex1, pieceIndex2...] }\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n\n  // Funzione per gestire il click su un pezzo\n  const handlePieceClick = (rowIndex, pieceIndex) => {\n    if (currentPlayer !== PLAYER_HUMAN || gameOver) return;\n    const currentPileCount = piles[rowIndex];\n    // Se si clicca su una riga diversa o si deseleziona cliccando sul primo pezzo non selezionato\n    if (selectedRow !== null && selectedRow !== rowIndex) {\n      // Non permettere selezione da righe multiple\n      console.log(\"Seleziona pezzi solo da una riga alla volta.\");\n      return;\n    }\n\n    // Calcola quanti pezzi sono stati selezionati cliccando su questo indice\n    const count = currentPileCount - pieceIndex;\n    if (selectedRow === rowIndex && count === selectedCount) {\n      // Deseleziona tutto se si clicca sullo stesso pezzo che definisce la selezione corrente\n      setSelectedRow(null);\n      setSelectedCount(0);\n    } else {\n      // Seleziona i pezzi\n      setSelectedRow(rowIndex);\n      setSelectedCount(count);\n    }\n  };\n\n  // Funzione per confermare la mossa dell'utente\n  const handleTakeTurn = () => {\n    if (selectedRow === null || selectedCount === 0 || gameOver) return;\n    const newPiles = [...piles];\n    newPiles[selectedRow] -= selectedCount;\n    setPiles(newPiles);\n    setSelectedRow(null);\n    setSelectedCount(0);\n\n    // Misère Play: Chi svuota le pile perde\n    if (checkGameOver(newPiles)) {\n      setGameOver(true);\n      setWinner(PLAYER_AI); // L'AI vince perché l'umano ha preso l'ultimo pezzo\n    } else {\n      setCurrentPlayer(PLAYER_AI);\n    }\n  };\n\n  // Funzione per la mossa dell'AI con strategia Nim-sum (Misère)\n  const performAiMove = () => {\n    setAiRemoving({}); // Resetta evidenziazione\n\n    const currentNimSum = calculateNimSum(piles);\n    let bestMove = null; // { rowIndex: number, removeCount: number }\n\n    // Controlla se il gioco è in una fase finale Misère\n    const pilesGreaterThanOne = piles.filter(count => count > 1).length;\n    const isMisereEndgame = pilesGreaterThanOne <= 1;\n    if (currentNimSum !== 0) {\n      // Posizione vincente (generalmente): trova una mossa per portare Nim-sum a 0\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] === 0) continue;\n        const targetSize = piles[i] ^ currentNimSum;\n        if (targetSize < piles[i]) {\n          const removeCount = piles[i] - targetSize;\n          // Controlla l'eccezione Misère\n          const isLosingMisereMove = isMisereEndgame && piles.every(count => count <= 1 || count === piles[i]) && piles.filter((count, idx) => (idx === i ? targetSize : count) === 1).length % 2 === 0;\n          if (!isLosingMisereMove) {\n            bestMove = {\n              rowIndex: i,\n              removeCount: removeCount\n            };\n            break; // Trovata la mossa vincente standard (o valida per Misère)\n          } else {\n            // La mossa standard perde in Misère. Dobbiamo fare una mossa diversa.\n            // Prova a rimuovere 1 pezzo in meno o in più se possibile,\n            // altrimenti questa è l'unica mossa possibile (anche se perdente).\n            if (removeCount > 1) {\n              bestMove = {\n                rowIndex: i,\n                removeCount: removeCount - 1\n              };\n              // Non fare break, potremmo trovare una mossa migliore da un'altra pila\n            } else if (piles[i] > removeCount) {\n              // Possiamo rimuovere di più?\n              bestMove = {\n                rowIndex: i,\n                removeCount: removeCount + 1\n              };\n              // Non fare break\n            } else {\n              // Siamo costretti a fare la mossa \"perdente\" standard\n              bestMove = {\n                rowIndex: i,\n                removeCount: removeCount\n              };\n              // Non fare break, magari un'altra pila offre alternative\n            }\n            // Se abbiamo trovato una mossa alternativa, continuiamo a cercare\n            // nel caso un'altra pila offra la mossa standard non problematica.\n            // Se non ne troviamo altre, useremo questa alternativa.\n            // Se troviamo la mossa standard non problematica da un'altra pila,\n            // sovrascriverà questa mossa alternativa.\n          }\n        }\n      }\n      // Se dopo il ciclo non abbiamo trovato una mossa standard valida e\n      // abbiamo solo mosse alternative o la mossa standard \"perdente\", usiamo quella trovata.\n      // Se non abbiamo trovato NESSUNA mossa che porti a Nim-sum 0 (non dovrebbe accadere se Nim-sum != 0),\n      // allora bestMove sarà ancora null qui.\n      if (!bestMove) {\n        // Fallback se la logica sopra fallisce o siamo costretti alla mossa perdente\n        // e non abbiamo trovato alternative. Scegli la prima mossa valida trovata\n        // che portava a Nim-sum 0, anche se era \"perdente\" in Misère.\n        for (let i = 0; i < piles.length; i++) {\n          if (piles[i] === 0) continue;\n          const targetSize = piles[i] ^ currentNimSum;\n          if (targetSize < piles[i]) {\n            bestMove = {\n              rowIndex: i,\n              removeCount: piles[i] - targetSize\n            };\n            break;\n          }\n        }\n      }\n    }\n    if (bestMove === null) {\n      // Posizione perdente (Nim-sum è 0) o fallback:\n      // Fai una mossa semplice, rimuovi 1 pezzo dalla pila più grande.\n      let largestPileIndex = -1;\n      let maxPieces = 0;\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] > maxPieces) {\n          maxPieces = piles[i];\n          largestPileIndex = i;\n        }\n      }\n      if (largestPileIndex !== -1) {\n        bestMove = {\n          rowIndex: largestPileIndex,\n          removeCount: 1\n        };\n      } else {\n        // Non dovrebbe accadere se il gioco non è finito, ma per sicurezza...\n        console.error(\"AI non può muovere!\");\n        return; // Nessuna mossa possibile\n      }\n    }\n\n    // Esegui la mossa scelta\n    const {\n      rowIndex: aiRowIndex,\n      removeCount: aiRemoveCount\n    } = bestMove;\n    const newPiles = [...piles];\n    newPiles[aiRowIndex] -= aiRemoveCount;\n\n    // Evidenzia i pezzi\n    const removingIndices = [];\n    const startPieceIndex = piles[aiRowIndex] - aiRemoveCount;\n    for (let i = 0; i < aiRemoveCount; i++) {\n      removingIndices.push(startPieceIndex + i);\n    }\n    setAiRemoving({\n      [aiRowIndex]: removingIndices\n    });\n\n    // Applica la mossa dopo un ritardo\n    setTimeout(() => {\n      setPiles(newPiles);\n      setAiRemoving({}); // Rimuovi evidenziazione\n\n      // Misère Play: Chi svuota le pile perde\n      if (checkGameOver(newPiles)) {\n        setGameOver(true);\n        setWinner(PLAYER_HUMAN); // L'umano vince perché l'AI ha preso l'ultimo pezzo\n      } else {\n        setCurrentPlayer(PLAYER_HUMAN);\n      }\n    }, AI_DELAY);\n  };\n\n  // Controlla se il gioco è finito\n  const checkGameOver = currentPiles => {\n    return currentPiles.every(count => count === 0);\n  };\n\n  // Effetto per triggerare la mossa dell'AI quando è il suo turno\n  useEffect(() => {\n    if (currentPlayer === PLAYER_AI && !gameOver) {\n      // Aggiungi un ritardo per far vedere la mossa dell'AI\n      const timer = setTimeout(performAiMove, AI_DELAY / 2); // Inizia la logica un po' prima\n      return () => clearTimeout(timer);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentPlayer, gameOver, piles]); // Aggiunto piles per rieseguire se le pile cambiano esternamente\n\n  // Determina lo stato del gioco da visualizzare\n  let status;\n  if (gameOver) {\n    // Il messaggio di vittoria ora riflette la regola Misère\n    status = winner === PLAYER_HUMAN ? 'Hai vinto! (L\\'AI ha preso l\\'ultimo pezzo)' : 'L\\'AI ha vinto! (Hai preso l\\'ultimo pezzo)';\n  } else {\n    status = currentPlayer === PLAYER_HUMAN ? 'Il tuo turno' : 'Turno dell\\'AI...';\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-status\",\n      children: status\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 207,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"nim-rows\",\n      children: piles.map((count, index) => /*#__PURE__*/_jsxDEV(NimRow, {\n        rowIndex: index,\n        piecesCount: count,\n        selectedCount: selectedRow === index ? selectedCount : 0,\n        aiRemovingIndices: aiRemoving[index] || [],\n        onPieceClick: handlePieceClick\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 210,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 208,\n      columnNumber: 7\n    }, this), currentPlayer === PLAYER_HUMAN && !gameOver && /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleTakeTurn,\n      disabled: selectedCount === 0,\n      children: \"Conferma Mossa\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 221,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 206,\n    columnNumber: 5\n  }, this);\n}\n_s(Game, \"tsxB+03avKhm5bRdhmAL65IS/+8=\");\n_c = Game;\nexport default Game;\nvar _c;\n$RefreshReg$(_c, \"Game\");","map":{"version":3,"names":["React","useState","useEffect","NimRow","jsxDEV","_jsxDEV","INITIAL_PILES","PLAYER_HUMAN","PLAYER_AI","AI_DELAY","calculateNimSum","piles","reduce","xorSum","count","Game","_s","setPiles","currentPlayer","setCurrentPlayer","selectedRow","setSelectedRow","selectedCount","setSelectedCount","aiRemoving","setAiRemoving","gameOver","setGameOver","winner","setWinner","handlePieceClick","rowIndex","pieceIndex","currentPileCount","console","log","handleTakeTurn","newPiles","checkGameOver","performAiMove","currentNimSum","bestMove","pilesGreaterThanOne","filter","length","isMisereEndgame","i","targetSize","removeCount","isLosingMisereMove","every","idx","largestPileIndex","maxPieces","error","aiRowIndex","aiRemoveCount","removingIndices","startPieceIndex","push","setTimeout","currentPiles","timer","clearTimeout","status","className","children","fileName","_jsxFileName","lineNumber","columnNumber","map","index","piecesCount","aiRemovingIndices","onPieceClick","onClick","disabled","_c","$RefreshReg$"],"sources":["/home/riki/Desktop/Nim/nim-game-react/src/components/Game.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport NimRow from './NimRow';\n\nconst INITIAL_PILES = [7, 5, 3]; // Configurazione iniziale delle pile aggiornata\nconst PLAYER_HUMAN = 'human';\nconst PLAYER_AI = 'ai';\nconst AI_DELAY = 1500; // Ritardo per la mossa dell'AI in ms\n\n// Funzione helper per calcolare il Nim-sum\nconst calculateNimSum = (piles) => piles.reduce((xorSum, count) => xorSum ^ count, 0);\n\nfunction Game() {\n  const [piles, setPiles] = useState(INITIAL_PILES);\n  const [currentPlayer, setCurrentPlayer] = useState(PLAYER_HUMAN);\n  const [selectedRow, setSelectedRow] = useState(null);\n  const [selectedCount, setSelectedCount] = useState(0);\n  const [aiRemoving, setAiRemoving] = useState({}); // { rowIndex: [pieceIndex1, pieceIndex2...] }\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n\n  // Funzione per gestire il click su un pezzo\n  const handlePieceClick = (rowIndex, pieceIndex) => {\n    if (currentPlayer !== PLAYER_HUMAN || gameOver) return;\n\n    const currentPileCount = piles[rowIndex];\n    // Se si clicca su una riga diversa o si deseleziona cliccando sul primo pezzo non selezionato\n    if (selectedRow !== null && selectedRow !== rowIndex) {\n        // Non permettere selezione da righe multiple\n        console.log(\"Seleziona pezzi solo da una riga alla volta.\");\n        return;\n    }\n\n    // Calcola quanti pezzi sono stati selezionati cliccando su questo indice\n    const count = currentPileCount - pieceIndex;\n\n    if (selectedRow === rowIndex && count === selectedCount) {\n        // Deseleziona tutto se si clicca sullo stesso pezzo che definisce la selezione corrente\n        setSelectedRow(null);\n        setSelectedCount(0);\n    } else {\n        // Seleziona i pezzi\n        setSelectedRow(rowIndex);\n        setSelectedCount(count);\n    }\n  };\n\n  // Funzione per confermare la mossa dell'utente\n  const handleTakeTurn = () => {\n    if (selectedRow === null || selectedCount === 0 || gameOver) return;\n\n    const newPiles = [...piles];\n    newPiles[selectedRow] -= selectedCount;\n    setPiles(newPiles);\n    setSelectedRow(null);\n    setSelectedCount(0);\n\n    // Misère Play: Chi svuota le pile perde\n    if (checkGameOver(newPiles)) {\n        setGameOver(true);\n        setWinner(PLAYER_AI); // L'AI vince perché l'umano ha preso l'ultimo pezzo\n    } else {\n        setCurrentPlayer(PLAYER_AI);\n    }\n  };\n\n  // Funzione per la mossa dell'AI con strategia Nim-sum (Misère)\n  const performAiMove = () => {\n    setAiRemoving({}); // Resetta evidenziazione\n\n    const currentNimSum = calculateNimSum(piles);\n    let bestMove = null; // { rowIndex: number, removeCount: number }\n\n    // Controlla se il gioco è in una fase finale Misère\n    const pilesGreaterThanOne = piles.filter(count => count > 1).length;\n    const isMisereEndgame = pilesGreaterThanOne <= 1;\n\n    if (currentNimSum !== 0) {\n      // Posizione vincente (generalmente): trova una mossa per portare Nim-sum a 0\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] === 0) continue;\n        const targetSize = piles[i] ^ currentNimSum;\n        if (targetSize < piles[i]) {\n          const removeCount = piles[i] - targetSize;\n          // Controlla l'eccezione Misère\n          const isLosingMisereMove = isMisereEndgame && piles.every(count => count <= 1 || count === piles[i]) && piles.filter((count, idx) => (idx === i ? targetSize : count) === 1).length % 2 === 0;\n\n          if (!isLosingMisereMove) {\n            bestMove = { rowIndex: i, removeCount: removeCount };\n            break; // Trovata la mossa vincente standard (o valida per Misère)\n          } else {\n            // La mossa standard perde in Misère. Dobbiamo fare una mossa diversa.\n            // Prova a rimuovere 1 pezzo in meno o in più se possibile,\n            // altrimenti questa è l'unica mossa possibile (anche se perdente).\n            if (removeCount > 1) {\n                 bestMove = { rowIndex: i, removeCount: removeCount - 1 };\n                 // Non fare break, potremmo trovare una mossa migliore da un'altra pila\n            } else if (piles[i] > removeCount) { // Possiamo rimuovere di più?\n                 bestMove = { rowIndex: i, removeCount: removeCount + 1 };\n                 // Non fare break\n            } else {\n                 // Siamo costretti a fare la mossa \"perdente\" standard\n                 bestMove = { rowIndex: i, removeCount: removeCount };\n                 // Non fare break, magari un'altra pila offre alternative\n            }\n             // Se abbiamo trovato una mossa alternativa, continuiamo a cercare\n             // nel caso un'altra pila offra la mossa standard non problematica.\n             // Se non ne troviamo altre, useremo questa alternativa.\n             // Se troviamo la mossa standard non problematica da un'altra pila,\n             // sovrascriverà questa mossa alternativa.\n          }\n        }\n      }\n       // Se dopo il ciclo non abbiamo trovato una mossa standard valida e\n       // abbiamo solo mosse alternative o la mossa standard \"perdente\", usiamo quella trovata.\n       // Se non abbiamo trovato NESSUNA mossa che porti a Nim-sum 0 (non dovrebbe accadere se Nim-sum != 0),\n       // allora bestMove sarà ancora null qui.\n       if (!bestMove) {\n           // Fallback se la logica sopra fallisce o siamo costretti alla mossa perdente\n           // e non abbiamo trovato alternative. Scegli la prima mossa valida trovata\n           // che portava a Nim-sum 0, anche se era \"perdente\" in Misère.\n            for (let i = 0; i < piles.length; i++) {\n                if (piles[i] === 0) continue;\n                const targetSize = piles[i] ^ currentNimSum;\n                if (targetSize < piles[i]) {\n                    bestMove = { rowIndex: i, removeCount: piles[i] - targetSize };\n                    break;\n                }\n            }\n       }\n\n    }\n\n    if (bestMove === null) {\n      // Posizione perdente (Nim-sum è 0) o fallback:\n      // Fai una mossa semplice, rimuovi 1 pezzo dalla pila più grande.\n      let largestPileIndex = -1;\n      let maxPieces = 0;\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] > maxPieces) {\n          maxPieces = piles[i];\n          largestPileIndex = i;\n        }\n      }\n      if (largestPileIndex !== -1) {\n        bestMove = { rowIndex: largestPileIndex, removeCount: 1 };\n      } else {\n         // Non dovrebbe accadere se il gioco non è finito, ma per sicurezza...\n         console.error(\"AI non può muovere!\");\n         return; // Nessuna mossa possibile\n      }\n    }\n\n    // Esegui la mossa scelta\n    const { rowIndex: aiRowIndex, removeCount: aiRemoveCount } = bestMove;\n    const newPiles = [...piles];\n    newPiles[aiRowIndex] -= aiRemoveCount;\n\n    // Evidenzia i pezzi\n    const removingIndices = [];\n    const startPieceIndex = piles[aiRowIndex] - aiRemoveCount;\n    for (let i = 0; i < aiRemoveCount; i++) {\n      removingIndices.push(startPieceIndex + i);\n    }\n    setAiRemoving({ [aiRowIndex]: removingIndices });\n\n    // Applica la mossa dopo un ritardo\n    setTimeout(() => {\n      setPiles(newPiles);\n      setAiRemoving({}); // Rimuovi evidenziazione\n\n      // Misère Play: Chi svuota le pile perde\n      if (checkGameOver(newPiles)) {\n        setGameOver(true);\n        setWinner(PLAYER_HUMAN); // L'umano vince perché l'AI ha preso l'ultimo pezzo\n      } else {\n        setCurrentPlayer(PLAYER_HUMAN);\n      }\n    }, AI_DELAY);\n  };\n\n  // Controlla se il gioco è finito\n  const checkGameOver = (currentPiles) => {\n    return currentPiles.every(count => count === 0);\n  };\n\n  // Effetto per triggerare la mossa dell'AI quando è il suo turno\n  useEffect(() => {\n    if (currentPlayer === PLAYER_AI && !gameOver) {\n      // Aggiungi un ritardo per far vedere la mossa dell'AI\n      const timer = setTimeout(performAiMove, AI_DELAY / 2); // Inizia la logica un po' prima\n      return () => clearTimeout(timer);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentPlayer, gameOver, piles]); // Aggiunto piles per rieseguire se le pile cambiano esternamente\n\n  // Determina lo stato del gioco da visualizzare\n  let status;\n  if (gameOver) {\n    // Il messaggio di vittoria ora riflette la regola Misère\n    status = winner === PLAYER_HUMAN ? 'Hai vinto! (L\\'AI ha preso l\\'ultimo pezzo)' : 'L\\'AI ha vinto! (Hai preso l\\'ultimo pezzo)';\n  } else {\n    status = currentPlayer === PLAYER_HUMAN ? 'Il tuo turno' : 'Turno dell\\'AI...';\n  }\n\n  return (\n    <div className=\"game-container\">\n      <div className=\"game-status\">{status}</div>\n      <div className=\"nim-rows\">\n        {piles.map((count, index) => (\n          <NimRow\n            key={index}\n            rowIndex={index}\n            piecesCount={count}\n            selectedCount={selectedRow === index ? selectedCount : 0}\n            aiRemovingIndices={aiRemoving[index] || []}\n            onPieceClick={handlePieceClick}\n          />\n        ))}\n      </div>\n      {currentPlayer === PLAYER_HUMAN && !gameOver && (\n        <button onClick={handleTakeTurn} disabled={selectedCount === 0}>\n          Conferma Mossa\n        </button>\n      )}\n    </div>\n  );\n}\n\nexport default Game;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}