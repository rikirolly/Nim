{"ast":null,"code":"var _jsxFileName = \"/home/riki/Desktop/Nim/nim-game-react/src/components/Game.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport NimRow from './NimRow';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst INITIAL_PILES = [9, 7, 5, 3]; // Configurazione iniziale delle pile aggiornata\nconst PLAYER_HUMAN = 'human';\nconst PLAYER_AI = 'ai';\nconst AI_DELAY = 1500; // Ritardo per la mossa dell'AI in ms\n\n// Funzione helper per calcolare il Nim-sum\nconst calculateNimSum = piles => piles.reduce((xorSum, count) => xorSum ^ count, 0);\n\n// Funzione helper per calcolare le mosse vincenti suggerite (per Debug)\nconst calculateWinningMoves = piles => {\n  const winningMoves = [];\n  const currentNimSum = calculateNimSum(piles);\n  if (currentNimSum === 0) {\n    // Se il Nim-sum è già 0, qualsiasi mossa porta a un Nim-sum non zero.\n    // L'AI farà una mossa standard (es. rimuovere 1 dalla pila più grande).\n    // Non ci sono mosse \"vincenti\" immediate in termini di Nim-sum.\n    return [];\n  }\n\n  // Controlla se il gioco è in una fase finale Misère PRIMA della mossa\n  const pilesGreaterThanOneInitial = piles.filter(count => count > 1).length;\n  const isMisereEndgameInitial = pilesGreaterThanOneInitial <= 1;\n  for (let i = 0; i < piles.length; i++) {\n    if (piles[i] === 0) continue;\n    const targetSize = piles[i] ^ currentNimSum;\n    if (targetSize < piles[i]) {\n      const removeCount = piles[i] - targetSize;\n\n      // Simula lo stato dopo la mossa per controllare l'eccezione Misère\n      const tempPiles = [...piles];\n      tempPiles[i] = targetSize;\n      const pilesGreaterThanOneAfter = tempPiles.filter(count => count > 1).length;\n      const allPilesAreOneOrZeroAfter = pilesGreaterThanOneAfter === 0;\n      let isLosingMisereMove = false;\n      if (allPilesAreOneOrZeroAfter) {\n        // Se dopo la mossa rimangono solo pile da 1 (o 0)\n        const onesCountAfter = tempPiles.filter(count => count === 1).length;\n        if (onesCountAfter % 2 === 0) {\n          // Se il numero di pile da 1 è pari, questa mossa perde in Misère\n          isLosingMisereMove = true;\n        }\n      }\n\n      // Aggiungi la mossa solo se NON è una mossa perdente specifica di Misère\n      if (!isLosingMisereMove) {\n        winningMoves.push({\n          rowIndex: i,\n          removeCount: removeCount\n        });\n      }\n    }\n  }\n\n  // Se tutte le mosse che portano a Nim-sum 0 sono perdenti in Misère,\n  // allora non ci sono mosse \"vincenti\" da suggerire secondo la strategia standard+Misère.\n  // Tuttavia, per il debug, potremmo voler mostrare *tutte* le mosse che portano a Nim-sum 0,\n  // anche quelle perdenti in Misère, per capire la logica dell'AI.\n  // Decidiamo di mostrare tutte le mosse che portano a Nim-sum 0.\n  // Ricalcoliamo senza il check Misère per il solo scopo di visualizzazione debug.\n  const debugWinningMoves = [];\n  for (let i = 0; i < piles.length; i++) {\n    if (piles[i] === 0) continue;\n    const targetSize = piles[i] ^ currentNimSum;\n    if (targetSize < piles[i]) {\n      const removeCount = piles[i] - targetSize;\n      debugWinningMoves.push({\n        rowIndex: i,\n        removeCount: removeCount\n      });\n    }\n  }\n\n  // Restituisce le mosse calcolate per il debug (senza filtro Misère complesso,\n  // dato che l'AI lo gestirà internamente). Mostra le mosse che portano a Nim-Sum 0.\n  return debugWinningMoves;\n};\nfunction Game() {\n  _s();\n  const [piles, setPiles] = useState(INITIAL_PILES);\n  const [currentPlayer, setCurrentPlayer] = useState(PLAYER_HUMAN);\n  const [selectedRow, setSelectedRow] = useState(null);\n  const [selectedCount, setSelectedCount] = useState(0);\n  const [aiRemoving, setAiRemoving] = useState({}); // { rowIndex: [pieceIndex1, pieceIndex2...] }\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n  const [isDebugMode, setIsDebugMode] = useState(false); // Stato per la modalità debug\n\n  // Funzione per gestire il click su un pezzo\n  const handlePieceClick = (rowIndex, pieceIndex) => {\n    if (currentPlayer !== PLAYER_HUMAN || gameOver) return;\n    const currentPileCount = piles[rowIndex];\n    // Se si clicca su una riga diversa o si deseleziona cliccando sul primo pezzo non selezionato\n    if (selectedRow !== null && selectedRow !== rowIndex) {\n      // Non permettere selezione da righe multiple\n      console.log(\"Seleziona pezzi solo da una riga alla volta.\");\n      return;\n    }\n\n    // Calcola quanti pezzi sono stati selezionati cliccando su questo indice\n    const count = currentPileCount - pieceIndex;\n    if (selectedRow === rowIndex && count === selectedCount) {\n      // Deseleziona tutto se si clicca sullo stesso pezzo che definisce la selezione corrente\n      setSelectedRow(null);\n      setSelectedCount(0);\n    } else {\n      // Seleziona i pezzi\n      setSelectedRow(rowIndex);\n      setSelectedCount(count);\n    }\n  };\n\n  // Funzione per confermare la mossa dell'utente\n  const handleTakeTurn = () => {\n    if (selectedRow === null || selectedCount === 0 || gameOver) return;\n    const newPiles = [...piles];\n    newPiles[selectedRow] -= selectedCount;\n    setPiles(newPiles);\n    setSelectedRow(null);\n    setSelectedCount(0);\n\n    // Misère Play: Chi svuota le pile perde\n    if (checkGameOver(newPiles)) {\n      setGameOver(true);\n      setWinner(PLAYER_AI); // L'AI vince perché l'umano ha preso l'ultimo pezzo\n    } else {\n      setCurrentPlayer(PLAYER_AI);\n    }\n  };\n\n  // Funzione per la mossa dell'AI con strategia Nim-sum (Misère)\n  const performAiMove = () => {\n    setAiRemoving({}); // Resetta evidenziazione\n\n    const currentNimSum = calculateNimSum(piles);\n    let bestMove = null; // { rowIndex: number, removeCount: number }\n\n    // Controlla se il gioco è in una fase finale Misère\n    const pilesGreaterThanOne = piles.filter(count => count > 1).length;\n    const isMisereEndgame = pilesGreaterThanOne <= 1;\n    if (currentNimSum !== 0) {\n      // Posizione vincente (generalmente): trova una mossa per portare Nim-sum a 0\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] === 0) continue;\n        const targetSize = piles[i] ^ currentNimSum;\n        if (targetSize < piles[i]) {\n          const removeCount = piles[i] - targetSize;\n          // Controlla l'eccezione Misère\n          const isLosingMisereMove = isMisereEndgame && piles.every(count => count <= 1 || count === piles[i]) && piles.filter((count, idx) => (idx === i ? targetSize : count) === 1).length % 2 === 0;\n          if (!isLosingMisereMove) {\n            bestMove = {\n              rowIndex: i,\n              removeCount: removeCount\n            };\n            break; // Trovata la mossa vincente standard (o valida per Misère)\n          } else {\n            // La mossa standard perde in Misère. Dobbiamo fare una mossa diversa.\n            // Prova a rimuovere 1 pezzo in meno o in più se possibile,\n            // altrimenti questa è l'unica mossa possibile (anche se perdente).\n            if (removeCount > 1) {\n              bestMove = {\n                rowIndex: i,\n                removeCount: removeCount - 1\n              };\n              // Non fare break, potremmo trovare una mossa migliore da un'altra pila\n            } else if (piles[i] > removeCount) {\n              // Possiamo rimuovere di più?\n              bestMove = {\n                rowIndex: i,\n                removeCount: removeCount + 1\n              };\n              // Non fare break\n            } else {\n              // Siamo costretti a fare la mossa \"perdente\" standard\n              bestMove = {\n                rowIndex: i,\n                removeCount: removeCount\n              };\n              // Non fare break, magari un'altra pila offre alternative\n            }\n            // Se abbiamo trovato una mossa alternativa, continuiamo a cercare\n            // nel caso un'altra pila offra la mossa standard non problematica.\n            // Se non ne troviamo altre, useremo questa alternativa.\n            // Se troviamo la mossa standard non problematica da un'altra pila,\n            // sovrascriverà questa mossa alternativa.\n          }\n        }\n      }\n      // Se dopo il ciclo non abbiamo trovato una mossa standard valida e\n      // abbiamo solo mosse alternative o la mossa standard \"perdente\", usiamo quella trovata.\n      // Se non abbiamo trovato NESSUNA mossa che porti a Nim-sum 0 (non dovrebbe accadere se Nim-sum != 0),\n      // allora bestMove sarà ancora null qui.\n      if (!bestMove) {\n        // Fallback se la logica sopra fallisce o siamo costretti alla mossa perdente\n        // e non abbiamo trovato alternative. Scegli la prima mossa valida trovata\n        // che portava a Nim-sum 0, anche se era \"perdente\" in Misère.\n        for (let i = 0; i < piles.length; i++) {\n          if (piles[i] === 0) continue;\n          const targetSize = piles[i] ^ currentNimSum;\n          if (targetSize < piles[i]) {\n            bestMove = {\n              rowIndex: i,\n              removeCount: piles[i] - targetSize\n            };\n            break;\n          }\n        }\n      }\n    }\n    if (bestMove === null) {\n      // Posizione perdente (Nim-sum è 0) o fallback:\n      // Fai una mossa semplice, rimuovi 1 pezzo dalla pila più grande.\n      let largestPileIndex = -1;\n      let maxPieces = 0;\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] > maxPieces) {\n          maxPieces = piles[i];\n          largestPileIndex = i;\n        }\n      }\n      if (largestPileIndex !== -1) {\n        bestMove = {\n          rowIndex: largestPileIndex,\n          removeCount: 1\n        };\n      } else {\n        // Non dovrebbe accadere se il gioco non è finito, ma per sicurezza...\n        console.error(\"AI non può muovere!\");\n        return; // Nessuna mossa possibile\n      }\n    }\n\n    // Esegui la mossa scelta\n    const {\n      rowIndex: aiRowIndex,\n      removeCount: aiRemoveCount\n    } = bestMove;\n    const newPiles = [...piles];\n    newPiles[aiRowIndex] -= aiRemoveCount;\n\n    // Evidenzia i pezzi\n    const removingIndices = [];\n    const startPieceIndex = piles[aiRowIndex] - aiRemoveCount;\n    for (let i = 0; i < aiRemoveCount; i++) {\n      removingIndices.push(startPieceIndex + i);\n    }\n    setAiRemoving({\n      [aiRowIndex]: removingIndices\n    });\n\n    // Applica la mossa dopo un ritardo\n    setTimeout(() => {\n      setPiles(newPiles);\n      setAiRemoving({}); // Rimuovi evidenziazione\n\n      // Misère Play: Chi svuota le pile perde\n      if (checkGameOver(newPiles)) {\n        setGameOver(true);\n        setWinner(PLAYER_HUMAN); // L'umano vince perché l'AI ha preso l'ultimo pezzo\n      } else {\n        setCurrentPlayer(PLAYER_HUMAN);\n      }\n    }, AI_DELAY);\n  };\n\n  // Controlla se il gioco è finito\n  const checkGameOver = currentPiles => {\n    return currentPiles.every(count => count === 0);\n  };\n\n  // Effetto per triggerare la mossa dell'AI quando è il suo turno\n  useEffect(() => {\n    if (currentPlayer === PLAYER_AI && !gameOver) {\n      // Aggiungi un ritardo per far vedere la mossa dell'AI\n      const timer = setTimeout(performAiMove, AI_DELAY / 2); // Inizia la logica un po' prima\n      return () => clearTimeout(timer);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentPlayer, gameOver, piles]); // Aggiunto piles per rieseguire se le pile cambiano esternamente\n\n  // Funzione per attivare/disattivare la modalità debug\n  const toggleDebugMode = () => {\n    setIsDebugMode(prevMode => !prevMode);\n  };\n\n  // Determina lo stato del gioco da visualizzare\n  let status;\n  if (gameOver) {\n    // Il messaggio di vittoria ora riflette la regola Misère\n    status = winner === PLAYER_HUMAN ? 'Hai vinto! (L\\'AI ha preso l\\'ultimo pezzo)' : 'L\\'AI ha vinto! (Hai preso l\\'ultimo pezzo)';\n  } else {\n    status = currentPlayer === PLAYER_HUMAN ? 'Il tuo turno' : 'Turno dell\\'AI...';\n  }\n\n  // Calcola il Nim-sum corrente per la visualizzazione debug\n  const currentNimSum = calculateNimSum(piles);\n  const suggestedMoves = isDebugMode ? calculateWinningMoves(piles) : [];\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-status\",\n      children: status\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 287,\n      columnNumber: 7\n    }, this), isDebugMode && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"debug-info\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        children: [\"Nim-Sum (XOR): \", currentNimSum, \" (\", currentNimSum.toString(2), \")\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 292,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Mosse suggerite (per Nim-Sum = 0):\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 293,\n        columnNumber: 11\n      }, this), suggestedMoves.length > 0 ? /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: suggestedMoves.map((move, index) => /*#__PURE__*/_jsxDEV(\"li\", {\n          children: [\"Rimuovi \", move.removeCount, \" da Pila \", move.rowIndex + 1, \" (indice \", move.rowIndex, \")\"]\n        }, index, true, {\n          fileName: _jsxFileName,\n          lineNumber: 297,\n          columnNumber: 17\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 295,\n        columnNumber: 13\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        children: currentNimSum === 0 ? \"Nessuna mossa porta a Nim-Sum 0 (sei in P-position).\" : \"Errore nel calcolo mosse?\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 303,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 291,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"nim-rows\",\n      children: piles.map((count, index) => /*#__PURE__*/_jsxDEV(NimRow, {\n        rowIndex: index,\n        piecesCount: count,\n        selectedCount: selectedRow === index ? selectedCount : 0,\n        aiRemovingIndices: aiRemoving[index] || [],\n        onPieceClick: handlePieceClick\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 310,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 308,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"action-buttons\",\n      children: [currentPlayer === PLAYER_HUMAN && !gameOver && /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleTakeTurn,\n        disabled: selectedCount === 0,\n        children: \"Conferma Mossa\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 324,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: toggleDebugMode,\n        className: \"debug-button\",\n        children: isDebugMode ? 'Nascondi Debug' : 'Mostra Debug'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 329,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 322,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 286,\n    columnNumber: 5\n  }, this);\n}\n_s(Game, \"zVNGRUZXoOo+JhVYLb3d40C78EE=\");\n_c = Game;\nexport default Game;\nvar _c;\n$RefreshReg$(_c, \"Game\");","map":{"version":3,"names":["React","useState","useEffect","NimRow","jsxDEV","_jsxDEV","INITIAL_PILES","PLAYER_HUMAN","PLAYER_AI","AI_DELAY","calculateNimSum","piles","reduce","xorSum","count","calculateWinningMoves","winningMoves","currentNimSum","pilesGreaterThanOneInitial","filter","length","isMisereEndgameInitial","i","targetSize","removeCount","tempPiles","pilesGreaterThanOneAfter","allPilesAreOneOrZeroAfter","isLosingMisereMove","onesCountAfter","push","rowIndex","debugWinningMoves","Game","_s","setPiles","currentPlayer","setCurrentPlayer","selectedRow","setSelectedRow","selectedCount","setSelectedCount","aiRemoving","setAiRemoving","gameOver","setGameOver","winner","setWinner","isDebugMode","setIsDebugMode","handlePieceClick","pieceIndex","currentPileCount","console","log","handleTakeTurn","newPiles","checkGameOver","performAiMove","bestMove","pilesGreaterThanOne","isMisereEndgame","every","idx","largestPileIndex","maxPieces","error","aiRowIndex","aiRemoveCount","removingIndices","startPieceIndex","setTimeout","currentPiles","timer","clearTimeout","toggleDebugMode","prevMode","status","suggestedMoves","className","children","fileName","_jsxFileName","lineNumber","columnNumber","toString","map","move","index","piecesCount","aiRemovingIndices","onPieceClick","onClick","disabled","_c","$RefreshReg$"],"sources":["/home/riki/Desktop/Nim/nim-game-react/src/components/Game.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport NimRow from './NimRow';\n\nconst INITIAL_PILES = [9, 7, 5, 3]; // Configurazione iniziale delle pile aggiornata\nconst PLAYER_HUMAN = 'human';\nconst PLAYER_AI = 'ai';\nconst AI_DELAY = 1500; // Ritardo per la mossa dell'AI in ms\n\n// Funzione helper per calcolare il Nim-sum\nconst calculateNimSum = (piles) => piles.reduce((xorSum, count) => xorSum ^ count, 0);\n\n// Funzione helper per calcolare le mosse vincenti suggerite (per Debug)\nconst calculateWinningMoves = (piles) => {\n  const winningMoves = [];\n  const currentNimSum = calculateNimSum(piles);\n\n  if (currentNimSum === 0) {\n    // Se il Nim-sum è già 0, qualsiasi mossa porta a un Nim-sum non zero.\n    // L'AI farà una mossa standard (es. rimuovere 1 dalla pila più grande).\n    // Non ci sono mosse \"vincenti\" immediate in termini di Nim-sum.\n    return [];\n  }\n\n  // Controlla se il gioco è in una fase finale Misère PRIMA della mossa\n  const pilesGreaterThanOneInitial = piles.filter(count => count > 1).length;\n  const isMisereEndgameInitial = pilesGreaterThanOneInitial <= 1;\n\n\n  for (let i = 0; i < piles.length; i++) {\n    if (piles[i] === 0) continue;\n\n    const targetSize = piles[i] ^ currentNimSum;\n    if (targetSize < piles[i]) {\n      const removeCount = piles[i] - targetSize;\n\n      // Simula lo stato dopo la mossa per controllare l'eccezione Misère\n      const tempPiles = [...piles];\n      tempPiles[i] = targetSize;\n      const pilesGreaterThanOneAfter = tempPiles.filter(count => count > 1).length;\n      const allPilesAreOneOrZeroAfter = pilesGreaterThanOneAfter === 0;\n\n      let isLosingMisereMove = false;\n      if (allPilesAreOneOrZeroAfter) {\n          // Se dopo la mossa rimangono solo pile da 1 (o 0)\n          const onesCountAfter = tempPiles.filter(count => count === 1).length;\n          if (onesCountAfter % 2 === 0) {\n              // Se il numero di pile da 1 è pari, questa mossa perde in Misère\n              isLosingMisereMove = true;\n          }\n      }\n\n      // Aggiungi la mossa solo se NON è una mossa perdente specifica di Misère\n      if (!isLosingMisereMove) {\n          winningMoves.push({ rowIndex: i, removeCount: removeCount });\n      }\n    }\n  }\n\n   // Se tutte le mosse che portano a Nim-sum 0 sono perdenti in Misère,\n   // allora non ci sono mosse \"vincenti\" da suggerire secondo la strategia standard+Misère.\n   // Tuttavia, per il debug, potremmo voler mostrare *tutte* le mosse che portano a Nim-sum 0,\n   // anche quelle perdenti in Misère, per capire la logica dell'AI.\n   // Decidiamo di mostrare tutte le mosse che portano a Nim-sum 0.\n   // Ricalcoliamo senza il check Misère per il solo scopo di visualizzazione debug.\n   const debugWinningMoves = [];\n    for (let i = 0; i < piles.length; i++) {\n        if (piles[i] === 0) continue;\n        const targetSize = piles[i] ^ currentNimSum;\n        if (targetSize < piles[i]) {\n            const removeCount = piles[i] - targetSize;\n            debugWinningMoves.push({ rowIndex: i, removeCount: removeCount });\n        }\n    }\n\n\n  // Restituisce le mosse calcolate per il debug (senza filtro Misère complesso,\n  // dato che l'AI lo gestirà internamente). Mostra le mosse che portano a Nim-Sum 0.\n  return debugWinningMoves;\n};\n\n\nfunction Game() {\n  const [piles, setPiles] = useState(INITIAL_PILES);\n  const [currentPlayer, setCurrentPlayer] = useState(PLAYER_HUMAN);\n  const [selectedRow, setSelectedRow] = useState(null);\n  const [selectedCount, setSelectedCount] = useState(0);\n  const [aiRemoving, setAiRemoving] = useState({}); // { rowIndex: [pieceIndex1, pieceIndex2...] }\n  const [gameOver, setGameOver] = useState(false);\n  const [winner, setWinner] = useState(null);\n  const [isDebugMode, setIsDebugMode] = useState(false); // Stato per la modalità debug\n\n  // Funzione per gestire il click su un pezzo\n  const handlePieceClick = (rowIndex, pieceIndex) => {\n    if (currentPlayer !== PLAYER_HUMAN || gameOver) return;\n\n    const currentPileCount = piles[rowIndex];\n    // Se si clicca su una riga diversa o si deseleziona cliccando sul primo pezzo non selezionato\n    if (selectedRow !== null && selectedRow !== rowIndex) {\n        // Non permettere selezione da righe multiple\n        console.log(\"Seleziona pezzi solo da una riga alla volta.\");\n        return;\n    }\n\n    // Calcola quanti pezzi sono stati selezionati cliccando su questo indice\n    const count = currentPileCount - pieceIndex;\n\n    if (selectedRow === rowIndex && count === selectedCount) {\n        // Deseleziona tutto se si clicca sullo stesso pezzo che definisce la selezione corrente\n        setSelectedRow(null);\n        setSelectedCount(0);\n    } else {\n        // Seleziona i pezzi\n        setSelectedRow(rowIndex);\n        setSelectedCount(count);\n    }\n  };\n\n  // Funzione per confermare la mossa dell'utente\n  const handleTakeTurn = () => {\n    if (selectedRow === null || selectedCount === 0 || gameOver) return;\n\n    const newPiles = [...piles];\n    newPiles[selectedRow] -= selectedCount;\n    setPiles(newPiles);\n    setSelectedRow(null);\n    setSelectedCount(0);\n\n    // Misère Play: Chi svuota le pile perde\n    if (checkGameOver(newPiles)) {\n        setGameOver(true);\n        setWinner(PLAYER_AI); // L'AI vince perché l'umano ha preso l'ultimo pezzo\n    } else {\n        setCurrentPlayer(PLAYER_AI);\n    }\n  };\n\n  // Funzione per la mossa dell'AI con strategia Nim-sum (Misère)\n  const performAiMove = () => {\n    setAiRemoving({}); // Resetta evidenziazione\n\n    const currentNimSum = calculateNimSum(piles);\n    let bestMove = null; // { rowIndex: number, removeCount: number }\n\n    // Controlla se il gioco è in una fase finale Misère\n    const pilesGreaterThanOne = piles.filter(count => count > 1).length;\n    const isMisereEndgame = pilesGreaterThanOne <= 1;\n\n    if (currentNimSum !== 0) {\n      // Posizione vincente (generalmente): trova una mossa per portare Nim-sum a 0\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] === 0) continue;\n        const targetSize = piles[i] ^ currentNimSum;\n        if (targetSize < piles[i]) {\n          const removeCount = piles[i] - targetSize;\n          // Controlla l'eccezione Misère\n          const isLosingMisereMove = isMisereEndgame && piles.every(count => count <= 1 || count === piles[i]) && piles.filter((count, idx) => (idx === i ? targetSize : count) === 1).length % 2 === 0;\n\n          if (!isLosingMisereMove) {\n            bestMove = { rowIndex: i, removeCount: removeCount };\n            break; // Trovata la mossa vincente standard (o valida per Misère)\n          } else {\n            // La mossa standard perde in Misère. Dobbiamo fare una mossa diversa.\n            // Prova a rimuovere 1 pezzo in meno o in più se possibile,\n            // altrimenti questa è l'unica mossa possibile (anche se perdente).\n            if (removeCount > 1) {\n                 bestMove = { rowIndex: i, removeCount: removeCount - 1 };\n                 // Non fare break, potremmo trovare una mossa migliore da un'altra pila\n            } else if (piles[i] > removeCount) { // Possiamo rimuovere di più?\n                 bestMove = { rowIndex: i, removeCount: removeCount + 1 };\n                 // Non fare break\n            } else {\n                 // Siamo costretti a fare la mossa \"perdente\" standard\n                 bestMove = { rowIndex: i, removeCount: removeCount };\n                 // Non fare break, magari un'altra pila offre alternative\n            }\n             // Se abbiamo trovato una mossa alternativa, continuiamo a cercare\n             // nel caso un'altra pila offra la mossa standard non problematica.\n             // Se non ne troviamo altre, useremo questa alternativa.\n             // Se troviamo la mossa standard non problematica da un'altra pila,\n             // sovrascriverà questa mossa alternativa.\n          }\n        }\n      }\n       // Se dopo il ciclo non abbiamo trovato una mossa standard valida e\n       // abbiamo solo mosse alternative o la mossa standard \"perdente\", usiamo quella trovata.\n       // Se non abbiamo trovato NESSUNA mossa che porti a Nim-sum 0 (non dovrebbe accadere se Nim-sum != 0),\n       // allora bestMove sarà ancora null qui.\n       if (!bestMove) {\n           // Fallback se la logica sopra fallisce o siamo costretti alla mossa perdente\n           // e non abbiamo trovato alternative. Scegli la prima mossa valida trovata\n           // che portava a Nim-sum 0, anche se era \"perdente\" in Misère.\n            for (let i = 0; i < piles.length; i++) {\n                if (piles[i] === 0) continue;\n                const targetSize = piles[i] ^ currentNimSum;\n                if (targetSize < piles[i]) {\n                    bestMove = { rowIndex: i, removeCount: piles[i] - targetSize };\n                    break;\n                }\n            }\n       }\n\n    }\n\n    if (bestMove === null) {\n      // Posizione perdente (Nim-sum è 0) o fallback:\n      // Fai una mossa semplice, rimuovi 1 pezzo dalla pila più grande.\n      let largestPileIndex = -1;\n      let maxPieces = 0;\n      for (let i = 0; i < piles.length; i++) {\n        if (piles[i] > maxPieces) {\n          maxPieces = piles[i];\n          largestPileIndex = i;\n        }\n      }\n      if (largestPileIndex !== -1) {\n        bestMove = { rowIndex: largestPileIndex, removeCount: 1 };\n      } else {\n         // Non dovrebbe accadere se il gioco non è finito, ma per sicurezza...\n         console.error(\"AI non può muovere!\");\n         return; // Nessuna mossa possibile\n      }\n    }\n\n    // Esegui la mossa scelta\n    const { rowIndex: aiRowIndex, removeCount: aiRemoveCount } = bestMove;\n    const newPiles = [...piles];\n    newPiles[aiRowIndex] -= aiRemoveCount;\n\n    // Evidenzia i pezzi\n    const removingIndices = [];\n    const startPieceIndex = piles[aiRowIndex] - aiRemoveCount;\n    for (let i = 0; i < aiRemoveCount; i++) {\n      removingIndices.push(startPieceIndex + i);\n    }\n    setAiRemoving({ [aiRowIndex]: removingIndices });\n\n    // Applica la mossa dopo un ritardo\n    setTimeout(() => {\n      setPiles(newPiles);\n      setAiRemoving({}); // Rimuovi evidenziazione\n\n      // Misère Play: Chi svuota le pile perde\n      if (checkGameOver(newPiles)) {\n        setGameOver(true);\n        setWinner(PLAYER_HUMAN); // L'umano vince perché l'AI ha preso l'ultimo pezzo\n      } else {\n        setCurrentPlayer(PLAYER_HUMAN);\n      }\n    }, AI_DELAY);\n  };\n\n  // Controlla se il gioco è finito\n  const checkGameOver = (currentPiles) => {\n    return currentPiles.every(count => count === 0);\n  };\n\n  // Effetto per triggerare la mossa dell'AI quando è il suo turno\n  useEffect(() => {\n    if (currentPlayer === PLAYER_AI && !gameOver) {\n      // Aggiungi un ritardo per far vedere la mossa dell'AI\n      const timer = setTimeout(performAiMove, AI_DELAY / 2); // Inizia la logica un po' prima\n      return () => clearTimeout(timer);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentPlayer, gameOver, piles]); // Aggiunto piles per rieseguire se le pile cambiano esternamente\n\n  // Funzione per attivare/disattivare la modalità debug\n  const toggleDebugMode = () => {\n    setIsDebugMode(prevMode => !prevMode);\n  };\n\n  // Determina lo stato del gioco da visualizzare\n  let status;\n  if (gameOver) {\n    // Il messaggio di vittoria ora riflette la regola Misère\n    status = winner === PLAYER_HUMAN ? 'Hai vinto! (L\\'AI ha preso l\\'ultimo pezzo)' : 'L\\'AI ha vinto! (Hai preso l\\'ultimo pezzo)';\n  } else {\n    status = currentPlayer === PLAYER_HUMAN ? 'Il tuo turno' : 'Turno dell\\'AI...';\n  }\n\n  // Calcola il Nim-sum corrente per la visualizzazione debug\n  const currentNimSum = calculateNimSum(piles);\n  const suggestedMoves = isDebugMode ? calculateWinningMoves(piles) : [];\n\n  return (\n    <div className=\"game-container\">\n      <div className=\"game-status\">{status}</div>\n\n      {/* Visualizzazione Debug */}\n      {isDebugMode && (\n        <div className=\"debug-info\">\n          <div>Nim-Sum (XOR): {currentNimSum} ({currentNimSum.toString(2)})</div>\n          <div>Mosse suggerite (per Nim-Sum = 0):</div>\n          {suggestedMoves.length > 0 ? (\n            <ul>\n              {suggestedMoves.map((move, index) => (\n                <li key={index}>\n                  Rimuovi {move.removeCount} da Pila {move.rowIndex + 1} (indice {move.rowIndex})\n                </li>\n              ))}\n            </ul>\n          ) : (\n            <div>{currentNimSum === 0 ? \"Nessuna mossa porta a Nim-Sum 0 (sei in P-position).\" : \"Errore nel calcolo mosse?\"}</div>\n          )}\n        </div>\n      )}\n\n      <div className=\"nim-rows\">\n        {piles.map((count, index) => (\n          <NimRow\n            key={index}\n            rowIndex={index}\n            piecesCount={count}\n            selectedCount={selectedRow === index ? selectedCount : 0}\n            aiRemovingIndices={aiRemoving[index] || []}\n            onPieceClick={handlePieceClick}\n          />\n        ))}\n      </div>\n\n      {/* Pulsanti Azione */}\n      <div className=\"action-buttons\">\n        {currentPlayer === PLAYER_HUMAN && !gameOver && (\n          <button onClick={handleTakeTurn} disabled={selectedCount === 0}>\n            Conferma Mossa\n          </button>\n        )}\n        {/* Pulsante Debug */}\n        <button onClick={toggleDebugMode} className=\"debug-button\">\n          {isDebugMode ? 'Nascondi Debug' : 'Mostra Debug'}\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default Game;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}